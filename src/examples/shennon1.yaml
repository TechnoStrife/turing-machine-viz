name: Shennon 1
source code: |
  #Теорема  Шеннона №1

  # Всякая машина Тьюринга А может быть преобразована в эквивалентную машину
  # не более чем с двумя внутренними состояниями.

  # Доказательством теоремы будет схема построения такой машины. Причем строить будем, по сути, универсальную машину Тьюринга, использующую одну ленту и имеющую лишь два внутренних состояния, которая сможет моделировать работу любой машины Тьюринга.

  # Общая идея построения

  # В общих чертах метод построения таков. Для произвольной машины Тьюринга А с алфавитом из m букв (символов, записываемых на ленте, включая пустой символ) и с n внутренними состояниями мы построим машину В с двумя внутренними состояниями и алфавитом не более чем из 4mn+m символов. Машина В будет работать, по существу, так же, как и машина А. Во всех клетках ленты, кроме воспринимаемого считывающей головкой и одного смежного с ним, на ленте машины В записано то же, что и на ленте машины А в соответствующие такты работы двух машин.

  # Машина В моделирует поведение машины А, но хранит информацию о внутреннем состоянии машины А с помощью символов, записанных в клетке под считывающей головкой, и в клетке, которую считывающая головка машины А собирается посетить. Основная задача — своевременно освежать эту информацию и держать ее под считывающей головкой. Если последняя передвигается, то информацию о состоянии надо перенести в новый квадрат, используя всего два внутренних состояния машины В. Пусть, например, следующим состоянием машины А должно быть состояние 17 (согласно какой-нибудь системе счисления). Чтобы перенести его символ, считывающая головка "качается" вперед - назад между старой и новой клеткой 17 раз (точнее 18 раз в новую клетку и 17 раз назад в старую). В течение этого процесса символ, стоящий в новой клетке, пробегает своего рода последовательность счета, которая оканчивается символом, соответствующим состоянию 17 и в то же время сохраняющим информацию о предыдущем символе в этой клетке. Процесс качания возвращает также старую клетку к одному из элементарных символов (находящихся во взаимно однозначном соответствии с символами, используемыми машиной А), а именно к тому элементарному символу, который должен быть записан в этой клетке после окончания данной операции.

  # Два состояния машины В назовем α и β. Эти состояния используются двояко. Во-первых, при первом шаге качания они переносят в ближайшую подлежащую посещению клетку информацию о том, вправо (α) или влево (β) от новой клетки лежит старая клетка. Эта информация нужна в новой клетке, чтобы управляющий элемент передвинул считывающую головку назад в нужном направлении. После первого шага информация об этом сохраняется в новой клетке с помощью записанного там символа (последний индекс у). Во-вторых, состояния α и β используются, чтобы сообщить из старой клетки в новый o факте окончания качания. После первого шага качания состояние β переносится в новую клетку вплоть до конца качания, когда переносится α. Это означает конец операции, и новая клетка начинает затем действовать как передатчик и управляет следующим шагом вычисления.

  # Пусть машина А содержит:
  #     - m символов внешнего алфавита a1,…,j,…,m,
  #     - n внутренних состояний S1,…,i,…,n,
  # Тогда машина В будет содержать:
  #     - два  внутренних состояния α и β,
  #     - m обычных символов внешнего алфавита bi , являющихся аналогами ai,
  #     - 4mn особенных символов b, за счет которых производится расширение         внутренней памяти.


  #   Задача:
  # Если в конце слова встретилось 2 единицы подряд или больше, то стереть последнюю

  input: 
   - 'δ101110110λλλ' # как выполняются команды на обысной машине Тьюринга
   - 'δ101110110λλλ' # как выполняются команды на аналогичной МТ, имеющей всего 2 внутр.состояния
   - '000000000000' #i - номер ленточного символа
   - '000000000000' #j - номер внутреннего состояния машины
   - '000000000000' #+/- - назначение (роль) клетки: если клетка передает информацию во время «качания», то х = ”+”, а если получает – то х = ”-”. Сами клетки назовем соответственно: передатчик / приёмник.
   - '000000000000' #R/L положение другой особой клетки (машина В не может запомнить откуда она ушла): в зависимости от того, вправо или влево от воспринимаемой клетке должна передвинуться считывающая головка при качании, y = R или L.
   
  tapes: 6
  blank: ' '
  start state: alpha
  table:
    # 
    alpha:
      #S0.δ -> δ.R.alpha
      'δδ0000': beta 1R 2R 3R 4R1 5R+ 6RR
      '1δ01+R,0δ01+R': 2R 3R0 4R0 5R0 6R0 
      #S0.1 -> 1.R.S2
      '1111-L': beta 1R 2R 3R1 4R3 5R+ 6RR
      'λ113+R,0113+R,1113+R': beta 2R1 3R1 4R2 5R+ 6RR
      'λ112+R,0112+R,1112+R': beta 2R1 3R1 4R1 5R+ 6RR
      'λ111+R,0111+R,1111+R': alpha 2R 3R0 4R0 5R0 6R0
      
      #S0.0 -> 0.R.S1
      '0001-L': beta 1R 2R 3R0 4R2 5R+ 6RR
      'λ002+R,0002+R,1002+R': beta 2R 3R0 4R1 5R+ 6RR
      'λ001+R,0001+R,1001+R': alpha 2R 3R0 4R0 5R0 6R0
      
      #S0.λ -> λ.H.done
      'λλ0000': done
      
      #S1.0 -> 0.R.S1
      '0002-L': beta 1R 2R 3R 4R2 5R+ 6RR
      #S1.1 -> 1.R.S2
      '1112-L': beta 1R 2R 3R 4R3 5R+ 6RR
      
      #S1.λ -> λ.H.done
      'λλλ2-L': done 3L0 4L0 5L0 6L0
      
      #S2.0 -> 0.R.S1
      '0003-L': beta 1R 2R 3R 4R2 5R+ 6RR
      
      #S2.1 -> 1.R.S3
      '1113-L': beta 1R 2R 3R 4R4 5R+ 6RR
      '0114+R,1114+R,λ114+R': beta 2R 3R 4R3 5R 6R
      
      #S2.λ -> λ.H.done
      'λλλ3-L': done 3L0 4L0 5L0 6L0
      
      #S3.1 -> 1.R.S3
      '1114-L': beta 1R 2R 3R 4R 5R+ 6RR
      #S3.0 -> 0.R.S1
      '0004-L': beta 1R 2R 3R 4R2 5R+ 6RR
      
      #S3.λ -> λ.L.S4
      'λλλ4-L': alpha 1L 2L 3L 4L5 5L+ 6LL
      '110000': beta 2R 3R1 4R1 5R- 6RR
      '1111-R': beta 2R 3R 4R2 5R 6R
      '1112-R': beta 2R 3R 4R3 5R 6R
      '1113-R': beta 2R 3R 4R4 5R 6R
      '1114-R': beta 2R 3R 4R5 5R 6R
      '1115-R': done 1Lλ 2Lλ 3L0 4L0 5L0 6L0
      
      

    beta:
      
      # gets the states for 1
      '110000': alpha 2L 3L1 4L1 5L- 6LL
      '1111-L': alpha 2L 3L1 4L2 5L- 6LL
      '1112-L': alpha 2L 3L1 4L3 5L- 6LL
      '1113-L': alpha 2L 3L1 4L4 5L- 6LL
      #for 0
      '000000': alpha 2L 3L0 4L1 5L- 6LL
      '0001-L': alpha 2L 3L0 4L2 5L- 6LL
      '0002-L': alpha 2L 3L0 4L3 5L- 6LL
      '0003-L': alpha 2L 3L0 4L4 5L- 6LL
      # for λ
      'λλ0000': alpha 2L 3Lλ 4L1 5L- 6LL
      'λλλ1-L': alpha 2L 3Lλ 4L2 5L- 6LL
      'λλλ2-L': alpha 2L 3Lλ 4L3 5L- 6LL
      'λλλ3-L': alpha 2L 3Lλ 4L4 5L- 6LL
      
      # for end
      '1λλ5+L': alpha 2L 3L 4L4 5L 6L
      '1λλ4+L': alpha 2L 3L 4L3 5L 6L
      '1λλ3+L': alpha 2L 3L 4L2 5L 6L
      '1λλ2+L': alpha 2L 3L 4L1 5L 6L
      '1λλ1+L': alpha 2L 3L0 4L0 5L0 6L0
    done:
    
positions:
  alpha: {x: 440, y: 277.13}
  beta: {x: 320, y: 277.13}
  done: {x: 560, y: 277.13}
